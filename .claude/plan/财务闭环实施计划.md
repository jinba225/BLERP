# 财务闭环功能实施计划

**项目名称**: Better Laser ERP 财务闭环功能实施
**制定日期**: 2025-11-09
**目标周期**: 13个工作日 (约3周)
**当前状态**: 财务模型60%完成，业务集成缺失

---

## 已明确的决策

基于现有代码分析，以下技术决策已确定：

### 技术架构决策
- **后端框架**: Django 4.2 + Django REST Framework
- **数据库**: SQLite (开发) / MySQL 8.0 (生产)
- **前端**: Tailwind CSS + Alpine.js (保持现有技术栈)
- **事务处理**: 使用 `@transaction.atomic` 确保财务操作原子性
- **精度控制**: 使用 `Decimal` 类型处理所有金额计算

### 现有模型复用
- **Account** (会计科目) - ✅ 已完整实现
- **Journal/JournalEntry** (记账凭证) - ✅ 已完整实现
- **CustomerAccount** (应收账款) - ✅ 已有模型，需增强自动生成逻辑
- **SupplierAccount** (应付账款) - ✅ 已有模型，需增强自动生成逻辑
- **Payment** (收付款记录) - ✅ 已有模型，需增强核销逻辑

### 新增模型需求
- **Invoice** (发票管理) - ❌ 需要创建统一发票模型
- **AccountReconciliation** (对账单) - ❌ 需要创建对账模型
- **WriteOffRecord** (核销记录) - ❌ 需要创建核销记录模型

---

## 整体规划概述

### 项目目标

实施完整的财务闭环功能，确保业务流程与财务管理无缝集成，实现：
1. **自动化对账**: 采购订单/收货单对账，销售订单/发货单对账
2. **账款自动生成**: 业务单据触发应收/应付账款自动创建
3. **智能核销**: 收付款自动核销对应账款
4. **风险控制**: 发货前信用额度校验，超限预警
5. **发票管理**: 统一管理采购发票和销售发票

### 技术栈

- **Backend**: Django 4.2, DRF
- **Database**: MySQL 8.0 (models.py中使用DecimalField)
- **Transaction**: `@transaction.atomic` 装饰器
- **Computation**: `Decimal` 类型确保精度
- **Frontend**: Tailwind CSS, Alpine.js
- **Notification**: 集成现有Notification系统

### 主要阶段

1. **阶段1: 发票管理模块** (3天) - 基础设施建设
2. **阶段2: 采购对账与应付自动生成** (3天) - 采购流程闭环
3. **阶段3: 销售对账与应收自动生成** (3天) - 销售流程闭环
4. **阶段4: 账款核销逻辑** (2天) - 财务核心功能
5. **阶段5: 信用额度校验** (2天) - 风险控制

---

## 详细任务分解

### 阶段1: 发票管理模块 (3天)

#### 任务1.1: 创建Invoice模型及数据库迁移

**目标**: 建立统一的发票管理数据模型

**输入**:
- 现有finance模型结构
- 采购/销售订单关联需求

**输出**:
- `Invoice` 模型定义
- `InvoiceItem` 明细模型定义
- 数据库迁移文件

**涉及文件**:
```
apps/finance/models.py              # 新增Invoice和InvoiceItem模型
apps/finance/migrations/0XXX_add_invoice.py  # 数据库迁移
```

**实施细节**:

```python
# apps/finance/models.py 新增内容

class Invoice(BaseModel):
    """
    统一发票模型 (采购发票 + 销售发票)
    """
    INVOICE_TYPES = [
        ('purchase', '采购发票'),
        ('sales', '销售发票'),
    ]

    INVOICE_STATUS = [
        ('draft', '草稿'),
        ('issued', '已开具'),
        ('received', '已收到'),
        ('verified', '已认证'),
        ('cancelled', '已作废'),
    ]

    # 发票基本信息
    invoice_number = models.CharField('发票号码', max_length=100, unique=True)
    invoice_type = models.CharField('发票类型', max_length=20, choices=INVOICE_TYPES)
    invoice_code = models.CharField('发票代码', max_length=50, blank=True)
    status = models.CharField('状态', max_length=20, choices=INVOICE_STATUS, default='draft')

    # 关联方信息
    supplier = models.ForeignKey(
        'suppliers.Supplier',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='invoices',
        verbose_name='供应商'
    )
    customer = models.ForeignKey(
        'customers.Customer',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='invoices',
        verbose_name='客户'
    )

    # 日期信息
    invoice_date = models.DateField('开票日期')
    tax_date = models.DateField('税务日期', null=True, blank=True)

    # 金额信息
    amount_excluding_tax = models.DecimalField('不含税金额', max_digits=12, decimal_places=2, default=0)
    tax_rate = models.DecimalField('税率(%)', max_digits=5, decimal_places=2, default=13)
    tax_amount = models.DecimalField('税额', max_digits=12, decimal_places=2, default=0)
    total_amount = models.DecimalField('价税合计', max_digits=12, decimal_places=2, default=0)

    # 关联业务单据
    reference_type = models.CharField('关联类型', max_length=50, blank=True)  # 'purchase_order', 'sales_order'
    reference_id = models.CharField('关联单据ID', max_length=100, blank=True)
    reference_number = models.CharField('关联单据号', max_length=100, blank=True)

    # 发票图片/PDF
    attachment = models.FileField('发票附件', upload_to='invoices/%Y/%m/', blank=True, null=True)

    # 备注
    remark = models.TextField('备注', blank=True)

    class Meta:
        verbose_name = '发票'
        verbose_name_plural = '发票'
        db_table = 'finance_invoice'
        ordering = ['-invoice_date', '-created_at']

    def __str__(self):
        return f"{self.invoice_number} - {self.get_invoice_type_display()}"

    def calculate_totals(self):
        """计算发票金额"""
        # 从明细汇总
        self.amount_excluding_tax = sum([item.amount for item in self.items.all()])
        self.tax_amount = self.amount_excluding_tax * (self.tax_rate / Decimal('100'))
        self.total_amount = self.amount_excluding_tax + self.tax_amount


class InvoiceItem(BaseModel):
    """
    发票明细
    """
    invoice = models.ForeignKey(
        Invoice,
        on_delete=models.CASCADE,
        related_name='items',
        verbose_name='发票'
    )
    product = models.ForeignKey(
        'products.Product',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='产品'
    )

    # 产品描述
    description = models.CharField('品名', max_length=200)
    specification = models.CharField('规格型号', max_length=200, blank=True)
    unit = models.CharField('单位', max_length=50, blank=True)

    # 数量和金额
    quantity = models.DecimalField('数量', max_digits=12, decimal_places=4)
    unit_price = models.DecimalField('单价', max_digits=12, decimal_places=2)
    amount = models.DecimalField('金额', max_digits=12, decimal_places=2, default=0)
    tax_rate = models.DecimalField('税率(%)', max_digits=5, decimal_places=2, default=13)
    tax_amount = models.DecimalField('税额', max_digits=12, decimal_places=2, default=0)

    sort_order = models.PositiveIntegerField('排序', default=0)

    class Meta:
        verbose_name = '发票明细'
        verbose_name_plural = '发票明细'
        db_table = 'finance_invoice_item'
        ordering = ['sort_order']

    def save(self, *args, **kwargs):
        # 计算金额
        self.amount = self.quantity * self.unit_price
        self.tax_amount = self.amount * (self.tax_rate / Decimal('100'))
        super().save(*args, **kwargs)
```

**验证标准**:
- ✅ 模型字段完整，包含所有必要信息
- ✅ 迁移成功执行，数据库表正常创建
- ✅ Admin后台可正常CRUD发票
- ✅ 金额计算逻辑正确 (不含税金额 + 税额 = 价税合计)

**预估工作量**: 0.5天

---

#### 任务1.2: 实现发票CRUD视图和模板

**目标**: 提供发票管理的Web界面

**输入**:
- Invoice模型
- 现有sales/purchase视图作为参考

**输出**:
- 发票列表/详情/创建/编辑视图
- 对应HTML模板
- URL路由配置

**涉及文件**:
```
apps/finance/views.py               # 新增invoice相关视图
apps/finance/urls.py                # 新增路由
apps/finance/forms.py               # 新增InvoiceForm (如需要)
templates/finance/invoice_list.html
templates/finance/invoice_detail.html
templates/finance/invoice_form.html
```

**实施细节**:

```python
# apps/finance/views.py 新增视图

@login_required
def invoice_list(request):
    """发票列表"""
    invoice_type = request.GET.get('type', '')
    status = request.GET.get('status', '')

    invoices = Invoice.objects.all()

    if invoice_type:
        invoices = invoices.filter(invoice_type=invoice_type)
    if status:
        invoices = invoices.filter(status=status)

    # 分页
    paginator = Paginator(invoices, 20)
    page = request.GET.get('page', 1)
    invoices_page = paginator.get_page(page)

    context = {
        'invoices': invoices_page,
        'invoice_type': invoice_type,
        'status': status,
    }
    return render(request, 'finance/invoice_list.html', context)


@login_required
def invoice_detail(request, pk):
    """发票详情"""
    invoice = get_object_or_404(Invoice, pk=pk)
    context = {'invoice': invoice}
    return render(request, 'finance/invoice_detail.html', context)


@login_required
@transaction.atomic
def invoice_create(request):
    """创建发票"""
    if request.method == 'POST':
        # 处理表单提交
        # ... 保存发票主表和明细
        pass
    else:
        context = {
            'invoice_types': Invoice.INVOICE_TYPES,
            'tax_rates': [13, 9, 6, 3, 0],  # 常用税率
        }
        return render(request, 'finance/invoice_form.html', context)


@login_required
@transaction.atomic
def invoice_update(request, pk):
    """编辑发票"""
    invoice = get_object_or_404(Invoice, pk=pk)
    # ... 编辑逻辑
    pass


@login_required
def invoice_delete(request, pk):
    """删除发票"""
    invoice = get_object_or_404(Invoice, pk=pk)
    if request.method == 'POST':
        invoice.delete()
        messages.success(request, '发票已删除')
        return redirect('finance:invoice_list')
    return render(request, 'finance/invoice_confirm_delete.html', {'invoice': invoice})
```

**验证标准**:
- ✅ 发票列表页面正常显示，支持筛选
- ✅ 可创建采购发票和销售发票
- ✅ 发票明细可正常添加/编辑
- ✅ 金额自动计算正确
- ✅ 可关联采购订单或销售订单

**预估工作量**: 1.5天

---

#### 任务1.3: 集成发票到采购/销售流程

**目标**: 在业务单据中支持关联发票

**输入**:
- 发票CRUD功能
- 现有采购订单/销售订单视图

**输出**:
- 采购订单详情页显示关联发票
- 销售订单详情页显示关联发票
- 快速创建发票功能

**涉及文件**:
```
apps/purchase/views.py              # 修改订单详情视图
apps/sales/views.py                 # 修改订单详情视图
templates/purchase/order_detail.html  # 添加发票区域
templates/sales/order_detail.html     # 添加发票区域
```

**实施细节**:

```python
# apps/purchase/views.py 修改

@login_required
def order_detail(request, pk):
    """采购订单详情 (增强版)"""
    order = get_object_or_404(PurchaseOrder, pk=pk)

    # 查询关联发票
    invoices = Invoice.objects.filter(
        invoice_type='purchase',
        reference_type='purchase_order',
        reference_id=str(order.id)
    )

    context = {
        'order': order,
        'invoices': invoices,  # 新增
    }
    return render(request, 'purchase/order_detail.html', context)


# apps/purchase/views.py 新增快速创建发票功能
@login_required
@transaction.atomic
def order_create_invoice(request, pk):
    """从采购订单快速创建发票"""
    order = get_object_or_404(PurchaseOrder, pk=pk)

    if request.method == 'POST':
        # 创建发票
        invoice = Invoice.objects.create(
            invoice_number=request.POST.get('invoice_number'),
            invoice_type='purchase',
            supplier=order.supplier,
            invoice_date=request.POST.get('invoice_date'),
            reference_type='purchase_order',
            reference_id=str(order.id),
            reference_number=order.order_number,
            created_by=request.user,
        )

        # 从订单明细创建发票明细
        for order_item in order.items.all():
            InvoiceItem.objects.create(
                invoice=invoice,
                product=order_item.product,
                description=order_item.product.name,
                quantity=order_item.quantity,
                unit_price=order_item.unit_price,
                created_by=request.user,
            )

        # 计算发票金额
        invoice.calculate_totals()
        invoice.save()

        messages.success(request, f'发票 {invoice.invoice_number} 创建成功')
        return redirect('purchase:order_detail', pk=pk)

    context = {'order': order}
    return render(request, 'purchase/order_invoice_form.html', context)
```

**验证标准**:
- ✅ 采购订单详情页显示关联发票列表
- ✅ 销售订单详情页显示关联发票列表
- ✅ 可从订单快速创建发票
- ✅ 发票明细自动从订单明细生成

**预估工作量**: 1天

---

### 阶段2: 采购对账与应付自动生成 (3天)

#### 任务2.1: 创建对账单模型

**目标**: 建立采购对账单数据模型

**输入**:
- 采购订单模型
- 收货单模型
- 发票模型

**输出**:
- `PurchaseReconciliation` 对账单模型
- `ReconciliationItem` 对账明细模型
- 数据库迁移

**涉及文件**:
```
apps/finance/models.py              # 新增对账单模型
apps/finance/migrations/0XXX_add_reconciliation.py
```

**实施细节**:

```python
# apps/finance/models.py 新增

class PurchaseReconciliation(BaseModel):
    """
    采购对账单
    自动关联: 采购订单 + 收货单 + 发票
    """
    RECONCILIATION_STATUS = [
        ('draft', '草稿'),
        ('submitted', '已提交'),
        ('confirmed', '已确认'),
        ('approved', '已审核'),
        ('completed', '已完成'),
    ]

    # 对账单信息
    reconciliation_number = models.CharField('对账单号', max_length=100, unique=True)
    status = models.CharField('状态', max_length=20, choices=RECONCILIATION_STATUS, default='draft')

    # 供应商
    supplier = models.ForeignKey(
        'suppliers.Supplier',
        on_delete=models.CASCADE,
        related_name='reconciliations',
        verbose_name='供应商'
    )

    # 关联单据
    purchase_order = models.ForeignKey(
        'purchase.PurchaseOrder',
        on_delete=models.CASCADE,
        related_name='reconciliations',
        verbose_name='采购订单'
    )

    # 日期范围
    start_date = models.DateField('开始日期')
    end_date = models.DateField('结束日期')
    reconciliation_date = models.DateField('对账日期')

    # 金额统计
    order_amount = models.DecimalField('订单金额', max_digits=12, decimal_places=2, default=0)
    received_amount = models.DecimalField('已收货金额', max_digits=12, decimal_places=2, default=0)
    invoiced_amount = models.DecimalField('已开票金额', max_digits=12, decimal_places=2, default=0)
    payable_amount = models.DecimalField('应付金额', max_digits=12, decimal_places=2, default=0)
    paid_amount = models.DecimalField('已付金额', max_digits=12, decimal_places=2, default=0)
    balance = models.DecimalField('对账余额', max_digits=12, decimal_places=2, default=0)

    # 人员
    prepared_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='prepared_reconciliations',
        verbose_name='制单人'
    )
    confirmed_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='confirmed_reconciliations',
        verbose_name='确认人'
    )

    notes = models.TextField('备注', blank=True)

    class Meta:
        verbose_name = '采购对账单'
        verbose_name_plural = '采购对账单'
        db_table = 'finance_purchase_reconciliation'
        ordering = ['-reconciliation_date', '-created_at']

    def calculate_amounts(self):
        """计算对账金额"""
        # 订单金额
        self.order_amount = self.purchase_order.total_amount

        # 已收货金额 (从收货单汇总)
        receipts = self.purchase_order.receipts.filter(status='received')
        self.received_amount = sum([
            receipt.items.aggregate(
                total=Sum(F('received_quantity') * F('order_item__unit_price'))
            )['total'] or 0
            for receipt in receipts
        ])

        # 已开票金额
        invoices = Invoice.objects.filter(
            invoice_type='purchase',
            reference_type='purchase_order',
            reference_id=str(self.purchase_order.id),
            status__in=['issued', 'verified']
        )
        self.invoiced_amount = invoices.aggregate(Sum('total_amount'))['total_amount__sum'] or 0

        # 应付金额 = 已收货金额 (以实际收货为准)
        self.payable_amount = self.received_amount

        # 已付金额
        supplier_accounts = SupplierAccount.objects.filter(purchase_order=self.purchase_order)
        self.paid_amount = supplier_accounts.aggregate(Sum('paid_amount'))['paid_amount__sum'] or 0

        # 对账余额 = 应付金额 - 已付金额
        self.balance = self.payable_amount - self.paid_amount


class ReconciliationItem(BaseModel):
    """
    对账明细
    """
    reconciliation = models.ForeignKey(
        PurchaseReconciliation,
        on_delete=models.CASCADE,
        related_name='items',
        verbose_name='对账单'
    )

    # 关联收货单
    receipt = models.ForeignKey(
        'purchase.PurchaseReceipt',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='收货单'
    )

    # 产品信息
    product = models.ForeignKey(
        'products.Product',
        on_delete=models.SET_NULL,
        null=True,
        verbose_name='产品'
    )

    # 数量和金额
    ordered_quantity = models.DecimalField('订购数量', max_digits=12, decimal_places=4)
    received_quantity = models.DecimalField('收货数量', max_digits=12, decimal_places=4)
    unit_price = models.DecimalField('单价', max_digits=12, decimal_places=2)
    amount = models.DecimalField('金额', max_digits=12, decimal_places=2, default=0)

    class Meta:
        verbose_name = '对账明细'
        verbose_name_plural = '对账明细'
        db_table = 'finance_reconciliation_item'

    def save(self, *args, **kwargs):
        self.amount = self.received_quantity * self.unit_price
        super().save(*args, **kwargs)
```

**验证标准**:
- ✅ 对账单模型字段完整
- ✅ 金额计算逻辑正确
- ✅ 可关联采购订单、收货单、发票

**预估工作量**: 0.5天

---

#### 任务2.2: 实现自动对账功能

**目标**: 从采购订单自动生成对账单

**输入**:
- 采购订单数据
- 收货单数据
- 发票数据

**输出**:
- 自动对账视图
- 对账单列表/详情页面

**涉及文件**:
```
apps/finance/views.py               # 新增对账相关视图
apps/finance/urls.py                # 新增路由
templates/finance/reconciliation_list.html
templates/finance/reconciliation_detail.html
```

**实施细节**:

```python
# apps/finance/views.py 新增

@login_required
@transaction.atomic
def purchase_order_reconcile(request, order_pk):
    """
    采购订单对账
    自动生成对账单
    """
    order = get_object_or_404(PurchaseOrder, pk=order_pk)

    # 检查是否已有对账单
    existing = PurchaseReconciliation.objects.filter(
        purchase_order=order,
        status__in=['draft', 'submitted']
    ).first()

    if existing:
        messages.warning(request, f'订单已有对账单: {existing.reconciliation_number}')
        return redirect('finance:reconciliation_detail', pk=existing.pk)

    # 创建对账单
    from apps.core.utils import DocumentNumberGenerator

    reconciliation = PurchaseReconciliation.objects.create(
        reconciliation_number=DocumentNumberGenerator.generate('purchase_reconciliation'),
        supplier=order.supplier,
        purchase_order=order,
        start_date=order.order_date,
        end_date=timezone.now().date(),
        reconciliation_date=timezone.now().date(),
        prepared_by=request.user,
        created_by=request.user,
    )

    # 创建对账明细 (从收货单)
    receipts = order.receipts.filter(status='received')
    for receipt in receipts:
        for receipt_item in receipt.items.all():
            ReconciliationItem.objects.create(
                reconciliation=reconciliation,
                receipt=receipt,
                product=receipt_item.order_item.product,
                ordered_quantity=receipt_item.order_item.quantity,
                received_quantity=receipt_item.received_quantity,
                unit_price=receipt_item.order_item.unit_price,
                created_by=request.user,
            )

    # 计算对账金额
    reconciliation.calculate_amounts()
    reconciliation.save()

    messages.success(request, f'对账单 {reconciliation.reconciliation_number} 生成成功')
    return redirect('finance:reconciliation_detail', pk=reconciliation.pk)


@login_required
def reconciliation_list(request):
    """对账单列表"""
    reconciliations = PurchaseReconciliation.objects.all()

    # 筛选
    supplier_id = request.GET.get('supplier')
    status = request.GET.get('status')

    if supplier_id:
        reconciliations = reconciliations.filter(supplier_id=supplier_id)
    if status:
        reconciliations = reconciliations.filter(status=status)

    # 分页
    paginator = Paginator(reconciliations, 20)
    page = request.GET.get('page', 1)
    reconciliations_page = paginator.get_page(page)

    context = {
        'reconciliations': reconciliations_page,
        'supplier_id': supplier_id,
        'status': status,
    }
    return render(request, 'finance/reconciliation_list.html', context)
```

**验证标准**:
- ✅ 从采购订单可一键生成对账单
- ✅ 对账明细自动从收货单生成
- ✅ 各项金额计算正确 (订单金额、收货金额、应付金额等)
- ✅ 对账单列表页面正常显示

**预估工作量**: 1.5天

---

#### 任务2.3: 收货确认后自动创建应付账款

**目标**: 增强收货确认逻辑，自动生成应付账款

**输入**:
- 收货单确认操作
- 供应商账期信息

**输出**:
- 增强的 `receipt_receive` 视图
- 自动创建的 `SupplierAccount` 记录

**涉及文件**:
```
apps/purchase/views.py              # 修改receipt_receive视图
apps/suppliers/models.py            # 添加payment_terms字段 (如无)
```

**实施细节**:

```python
# apps/purchase/views.py 修改

@login_required
@transaction.atomic
def receipt_receive(request, pk):
    """
    确认收货 (增强版)
    新增: 自动创建应付账款
    """
    receipt = get_object_or_404(PurchaseReceipt, pk=pk)

    # 检查状态
    if receipt.status != 'draft':
        messages.error(request, '收货单已处理，无法重复确认')
        return redirect('purchase:receipt_detail', pk=pk)

    # 1. 库存入库 (原有逻辑)
    for receipt_item in receipt.items.all():
        from apps.inventory.models import InventoryTransaction
        InventoryTransaction.objects.create(
            transaction_type='purchase',
            product=receipt_item.order_item.product,
            warehouse=receipt.warehouse,
            quantity=receipt_item.received_quantity,
            unit_cost=receipt_item.order_item.unit_price,
            reference_type='purchase_receipt',
            reference_id=str(receipt.id),
            reference_number=receipt.receipt_number,
            operator=request.user,
        )

        # 更新订单已收货数量
        order_item = receipt_item.order_item
        order_item.received_quantity += receipt_item.received_quantity
        order_item.save()

    # 2. 更新收货单状态
    receipt.status = 'received'
    receipt.received_by = request.user
    receipt.save()

    # 3. 更新采购订单状态
    order = receipt.purchase_order
    total_ordered = sum([item.quantity for item in order.items.all()])
    total_received = sum([item.received_quantity for item in order.items.all()])

    if total_received >= total_ordered:
        order.status = 'received'
    else:
        order.status = 'partial_received'
    order.save()

    # ✅ 4. 新增: 自动创建应付账款
    # 计算本次收货金额
    received_amount = sum([
        item.received_quantity * item.order_item.unit_price
        for item in receipt.items.all()
    ])

    # 计算到期日 (供应商账期)
    from datetime import timedelta
    supplier = order.supplier
    payment_terms = supplier.payment_terms if hasattr(supplier, 'payment_terms') else order.payment_terms

    due_date = timezone.now().date()
    if payment_terms:
        # 简单解析账期
        if 'net_30' in payment_terms.lower() or '30' in payment_terms:
            due_date = due_date + timedelta(days=30)
        elif 'net_60' in payment_terms.lower() or '60' in payment_terms:
            due_date = due_date + timedelta(days=60)
        elif 'net_90' in payment_terms.lower() or '90' in payment_terms:
            due_date = due_date + timedelta(days=90)

    # 创建应付账款
    supplier_account = SupplierAccount.objects.create(
        supplier=order.supplier,
        purchase_order=order,
        invoice_date=timezone.now().date(),
        due_date=due_date,
        invoice_amount=received_amount,
        paid_amount=0,
        balance=received_amount,
        currency=order.currency,
        notes=f'收货单 {receipt.receipt_number} 应付账款',
        created_by=request.user,
    )

    # ✅ 5. 通知 (可选)
    from apps.core.models import Notification
    Notification.objects.create(
        recipient=order.buyer,  # 通知采购员
        title='收货完成，已生成应付账款',
        message=f'收货单 {receipt.receipt_number} 已确认收货，应付金额: ¥{received_amount}，到期日: {due_date}',
        notification_type='info',
        created_by=request.user,
    )

    messages.success(request, f'收货确认成功，已自动生成应付账款 ¥{received_amount}')
    return redirect('purchase:receipt_detail', pk=pk)
```

**验证标准**:
- ✅ 收货确认后自动创建 `SupplierAccount`
- ✅ 应付金额 = 本次收货金额
- ✅ 到期日根据供应商账期自动计算
- ✅ 通知相关人员

**预估工作量**: 1天

---

### 阶段3: 销售对账与应收自动生成 (3天)

#### 任务3.1: 创建销售对账单模型

**目标**: 建立销售对账单数据模型 (参考采购对账)

**输入**:
- 销售订单模型
- 发货单模型
- 发票模型

**输出**:
- `SalesReconciliation` 对账单模型
- 数据库迁移

**涉及文件**:
```
apps/finance/models.py              # 新增销售对账单模型
apps/finance/migrations/0XXX_add_sales_reconciliation.py
```

**实施细节**:

```python
# apps/finance/models.py 新增

class SalesReconciliation(BaseModel):
    """
    销售对账单
    自动关联: 销售订单 + 发货单 + 发票
    """
    RECONCILIATION_STATUS = [
        ('draft', '草稿'),
        ('submitted', '已提交'),
        ('confirmed', '已确认'),
        ('approved', '已审核'),
        ('completed', '已完成'),
    ]

    # 对账单信息
    reconciliation_number = models.CharField('对账单号', max_length=100, unique=True)
    status = models.CharField('状态', max_length=20, choices=RECONCILIATION_STATUS, default='draft')

    # 客户
    customer = models.ForeignKey(
        'customers.Customer',
        on_delete=models.CASCADE,
        related_name='reconciliations',
        verbose_name='客户'
    )

    # 关联单据
    sales_order = models.ForeignKey(
        'sales.SalesOrder',
        on_delete=models.CASCADE,
        related_name='reconciliations',
        verbose_name='销售订单'
    )

    # 日期范围
    start_date = models.DateField('开始日期')
    end_date = models.DateField('结束日期')
    reconciliation_date = models.DateField('对账日期')

    # 金额统计
    order_amount = models.DecimalField('订单金额', max_digits=12, decimal_places=2, default=0)
    delivered_amount = models.DecimalField('已发货金额', max_digits=12, decimal_places=2, default=0)
    invoiced_amount = models.DecimalField('已开票金额', max_digits=12, decimal_places=2, default=0)
    receivable_amount = models.DecimalField('应收金额', max_digits=12, decimal_places=2, default=0)
    received_amount = models.DecimalField('已收金额', max_digits=12, decimal_places=2, default=0)
    balance = models.DecimalField('对账余额', max_digits=12, decimal_places=2, default=0)

    # 人员
    prepared_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='prepared_sales_reconciliations',
        verbose_name='制单人'
    )
    confirmed_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='confirmed_sales_reconciliations',
        verbose_name='确认人'
    )

    notes = models.TextField('备注', blank=True)

    class Meta:
        verbose_name = '销售对账单'
        verbose_name_plural = '销售对账单'
        db_table = 'finance_sales_reconciliation'
        ordering = ['-reconciliation_date', '-created_at']

    def calculate_amounts(self):
        """计算对账金额"""
        # 订单金额
        self.order_amount = self.sales_order.total_amount

        # 已发货金额 (从发货单汇总)
        deliveries = self.sales_order.deliveries.filter(status__in=['shipped', 'delivered'])
        self.delivered_amount = sum([
            delivery.items.aggregate(
                total=Sum(F('quantity') * F('order_item__unit_price'))
            )['total'] or 0
            for delivery in deliveries
        ])

        # 已开票金额
        invoices = Invoice.objects.filter(
            invoice_type='sales',
            reference_type='sales_order',
            reference_id=str(self.sales_order.id),
            status__in=['issued', 'verified']
        )
        self.invoiced_amount = invoices.aggregate(Sum('total_amount'))['total_amount__sum'] or 0

        # 应收金额 = 已发货金额
        self.receivable_amount = self.delivered_amount

        # 已收金额
        customer_accounts = CustomerAccount.objects.filter(sales_order=self.sales_order)
        self.received_amount = customer_accounts.aggregate(Sum('paid_amount'))['paid_amount__sum'] or 0

        # 对账余额 = 应收金额 - 已收金额
        self.balance = self.receivable_amount - self.received_amount
```

**验证标准**:
- ✅ 销售对账单模型字段完整
- ✅ 金额计算逻辑正确
- ✅ 可关联销售订单、发货单、发票

**预估工作量**: 0.5天

---

#### 任务3.2: 实现销售自动对账功能

**目标**: 从销售订单自动生成对账单 (参考采购对账)

**输入**:
- 销售订单数据
- 发货单数据
- 发票数据

**输出**:
- 自动对账视图
- 对账单列表/详情页面

**涉及文件**:
```
apps/finance/views.py               # 新增销售对账相关视图
apps/finance/urls.py                # 新增路由
templates/finance/sales_reconciliation_list.html
templates/finance/sales_reconciliation_detail.html
```

**实施细节**:

```python
# apps/finance/views.py 新增

@login_required
@transaction.atomic
def sales_order_reconcile(request, order_pk):
    """
    销售订单对账
    自动生成对账单
    """
    order = get_object_or_404(SalesOrder, pk=order_pk)

    # 检查是否已有对账单
    existing = SalesReconciliation.objects.filter(
        sales_order=order,
        status__in=['draft', 'submitted']
    ).first()

    if existing:
        messages.warning(request, f'订单已有对账单: {existing.reconciliation_number}')
        return redirect('finance:sales_reconciliation_detail', pk=existing.pk)

    # 创建对账单
    from apps.core.utils import DocumentNumberGenerator

    reconciliation = SalesReconciliation.objects.create(
        reconciliation_number=DocumentNumberGenerator.generate('sales_reconciliation'),
        customer=order.customer,
        sales_order=order,
        start_date=order.order_date,
        end_date=timezone.now().date(),
        reconciliation_date=timezone.now().date(),
        prepared_by=request.user,
        created_by=request.user,
    )

    # 计算对账金额
    reconciliation.calculate_amounts()
    reconciliation.save()

    messages.success(request, f'对账单 {reconciliation.reconciliation_number} 生成成功')
    return redirect('finance:sales_reconciliation_detail', pk=reconciliation.pk)
```

**验证标准**:
- ✅ 从销售订单可一键生成对账单
- ✅ 各项金额计算正确 (订单金额、发货金额、应收金额等)
- ✅ 对账单列表页面正常显示

**预估工作量**: 1.5天

---

#### 任务3.3: 发货确认后自动创建应收账款

**目标**: 增强发货确认逻辑，自动生成应收账款

**输入**:
- 发货单确认操作
- 客户账期信息

**输出**:
- 增强的 `delivery_ship` 视图
- 自动创建的 `CustomerAccount` 记录

**涉及文件**:
```
apps/sales/views.py                 # 修改delivery_ship视图
```

**实施细节**:

```python
# apps/sales/views.py 修改

@login_required
@transaction.atomic
def delivery_ship(request, pk):
    """
    确认发货 (增强版)
    新增: 自动创建应收账款
    """
    delivery = get_object_or_404(Delivery, pk=pk)

    # 检查状态
    if delivery.status != 'preparing':
        messages.error(request, '发货单已处理，无法重复确认')
        return redirect('sales:delivery_detail', pk=pk)

    # 1. 库存出库 (原有逻辑)
    for delivery_item in delivery.items.all():
        from apps.inventory.models import InventoryTransaction
        InventoryTransaction.objects.create(
            transaction_type='sales',
            product=delivery_item.order_item.product,
            warehouse=delivery.warehouse,
            quantity=-delivery_item.quantity,  # 负数表示出库
            unit_cost=delivery_item.order_item.product.cost_price,
            reference_type='delivery',
            reference_id=str(delivery.id),
            reference_number=delivery.delivery_number,
            operator=request.user,
        )

        # 更新订单已发货数量
        order_item = delivery_item.order_item
        order_item.delivered_quantity += delivery_item.quantity
        order_item.save()

    # 2. 更新发货单状态
    delivery.status = 'shipped'
    delivery.shipped_by = request.user
    delivery.actual_date = timezone.now().date()
    delivery.save()

    # 3. 更新销售订单状态
    order = delivery.sales_order
    total_ordered = sum([item.quantity for item in order.items.all()])
    total_delivered = sum([item.delivered_quantity for item in order.items.all()])

    if total_delivered >= total_ordered:
        order.status = 'shipped'
    else:
        order.status = 'partial_shipped'
    order.shipped_date = timezone.now().date()
    order.save()

    # ✅ 4. 新增: 自动创建应收账款
    # 计算本次发货金额
    delivered_amount = sum([
        item.quantity * item.order_item.unit_price
        for item in delivery.items.all()
    ])

    # 计算到期日 (客户账期)
    from datetime import timedelta
    customer = order.customer
    payment_terms = customer.payment_terms if hasattr(customer, 'payment_terms') else order.payment_terms

    due_date = timezone.now().date()
    if payment_terms:
        if 'net_30' in payment_terms.lower():
            due_date = due_date + timedelta(days=30)
        elif 'net_60' in payment_terms.lower():
            due_date = due_date + timedelta(days=60)
        elif 'net_90' in payment_terms.lower():
            due_date = due_date + timedelta(days=90)

    # 创建应收账款
    customer_account = CustomerAccount.objects.create(
        customer=order.customer,
        sales_order=order,
        invoice_date=timezone.now().date(),
        due_date=due_date,
        invoice_amount=delivered_amount,
        paid_amount=0,
        balance=delivered_amount,
        currency=order.currency,
        notes=f'发货单 {delivery.delivery_number} 应收账款',
        created_by=request.user,
    )

    # ✅ 5. 通知 (可选)
    from apps.core.models import Notification
    Notification.objects.create(
        recipient=order.sales_rep,  # 通知销售
        title='发货完成，已生成应收账款',
        message=f'发货单 {delivery.delivery_number} 已确认发货，应收金额: ¥{delivered_amount}，到期日: {due_date}',
        notification_type='info',
        created_by=request.user,
    )

    messages.success(request, f'发货确认成功，已自动生成应收账款 ¥{delivered_amount}')
    return redirect('sales:delivery_detail', pk=pk)
```

**验证标准**:
- ✅ 发货确认后自动创建 `CustomerAccount`
- ✅ 应收金额 = 本次发货金额
- ✅ 到期日根据客户账期自动计算
- ✅ 通知相关人员

**预估工作量**: 1天

---

### 阶段4: 账款核销逻辑 (2天)

#### 任务4.1: 创建核销记录模型

**目标**: 建立核销记录数据模型

**输入**:
- Payment模型
- CustomerAccount/SupplierAccount模型

**输出**:
- `WriteOffRecord` 核销记录模型
- 数据库迁移

**涉及文件**:
```
apps/finance/models.py              # 新增核销记录模型
apps/finance/migrations/0XXX_add_writeoff.py
```

**实施细节**:

```python
# apps/finance/models.py 新增

class WriteOffRecord(BaseModel):
    """
    核销记录
    记录收付款对应账款的核销关系
    """
    WRITEOFF_TYPES = [
        ('receivable', '应收核销'),
        ('payable', '应付核销'),
    ]

    # 核销信息
    writeoff_number = models.CharField('核销单号', max_length=100, unique=True)
    writeoff_type = models.CharField('核销类型', max_length=20, choices=WRITEOFF_TYPES)
    writeoff_date = models.DateField('核销日期')

    # 关联收付款
    payment = models.ForeignKey(
        Payment,
        on_delete=models.CASCADE,
        related_name='writeoff_records',
        verbose_name='收付款记录'
    )

    # 关联账款
    customer_account = models.ForeignKey(
        CustomerAccount,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='writeoff_records',
        verbose_name='应收账款'
    )
    supplier_account = models.ForeignKey(
        SupplierAccount,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='writeoff_records',
        verbose_name='应付账款'
    )

    # 核销金额
    writeoff_amount = models.DecimalField('核销金额', max_digits=12, decimal_places=2)

    # 人员
    processed_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='处理人'
    )

    notes = models.TextField('备注', blank=True)

    class Meta:
        verbose_name = '核销记录'
        verbose_name_plural = '核销记录'
        db_table = 'finance_writeoff_record'
        ordering = ['-writeoff_date', '-created_at']

    def __str__(self):
        return f"{self.writeoff_number} - ¥{self.writeoff_amount}"
```

**验证标准**:
- ✅ 核销记录模型字段完整
- ✅ 可关联收付款和对应账款
- ✅ 支持部分核销

**预估工作量**: 0.5天

---

#### 任务4.2: 实现付款自动核销应付账款

**目标**: 付款记录创建时自动核销应付账款

**输入**:
- Payment创建操作 (付款类型)
- SupplierAccount数据

**输出**:
- 增强的Payment保存逻辑
- 自动更新SupplierAccount余额
- 创建WriteOffRecord记录

**涉及文件**:
```
apps/finance/models.py              # 修改Payment.save()方法
apps/finance/views.py               # 修改payment相关视图
```

**实施细节**:

```python
# apps/finance/models.py 修改Payment模型

class Payment(BaseModel):
    # ... 现有字段 ...

    def save(self, *args, **kwargs):
        # 先保存Payment记录
        is_new = self.pk is None
        super().save(*args, **kwargs)

        # 如果是新记录且已完成，执行核销逻辑
        if is_new and self.status == 'completed':
            if self.payment_type == 'payment':  # 付款
                self._process_payable_writeoff()
            elif self.payment_type == 'receipt':  # 收款
                self._process_receivable_writeoff()

    def _process_payable_writeoff(self):
        """
        处理应付款核销
        付款后自动核销对应的应付账款
        """
        from django.db import transaction

        # 如果payment关联了采购订单
        if self.reference_type == 'purchase_order' and self.reference_id:
            # 查找该订单的未付清应付账款
            supplier_accounts = SupplierAccount.objects.filter(
                purchase_order_id=self.reference_id,
                balance__gt=0
            ).order_by('due_date')  # 先核销即将到期的

            remaining_amount = self.amount  # 剩余待核销金额

            for account in supplier_accounts:
                if remaining_amount <= 0:
                    break

                # 计算本次核销金额
                writeoff_amount = min(remaining_amount, account.balance)

                # 更新应付账款余额
                account.balance -= writeoff_amount
                account.paid_amount += writeoff_amount

                # 更新状态
                if account.balance == 0:
                    account.status = 'paid'
                elif account.paid_amount > 0:
                    account.status = 'partial'

                account.save()

                # 创建核销记录
                from apps.core.utils import DocumentNumberGenerator
                WriteOffRecord.objects.create(
                    writeoff_number=DocumentNumberGenerator.generate('writeoff'),
                    writeoff_type='payable',
                    writeoff_date=self.payment_date,
                    payment=self,
                    supplier_account=account,
                    writeoff_amount=writeoff_amount,
                    processed_by=self.created_by,
                    notes=f'付款 {self.payment_number} 核销应付账款',
                    created_by=self.created_by,
                )

                remaining_amount -= writeoff_amount

    def _process_receivable_writeoff(self):
        """
        处理应收款核销
        收款后自动核销对应的应收账款
        """
        # 如果payment关联了销售订单
        if self.reference_type == 'sales_order' and self.reference_id:
            # 查找该订单的未收清应收账款
            customer_accounts = CustomerAccount.objects.filter(
                sales_order_id=self.reference_id,
                balance__gt=0
            ).order_by('due_date')  # 先核销即将到期的

            remaining_amount = self.amount  # 剩余待核销金额

            for account in customer_accounts:
                if remaining_amount <= 0:
                    break

                # 计算本次核销金额
                writeoff_amount = min(remaining_amount, account.balance)

                # 更新应收账款余额
                account.balance -= writeoff_amount
                account.paid_amount += writeoff_amount

                # 更新状态
                if account.balance == 0:
                    account.status = 'paid'
                elif account.paid_amount > 0:
                    account.status = 'partial'

                account.save()

                # 创建核销记录
                from apps.core.utils import DocumentNumberGenerator
                WriteOffRecord.objects.create(
                    writeoff_number=DocumentNumberGenerator.generate('writeoff'),
                    writeoff_type='receivable',
                    writeoff_date=self.payment_date,
                    payment=self,
                    customer_account=account,
                    writeoff_amount=writeoff_amount,
                    processed_by=self.created_by,
                    notes=f'收款 {self.payment_number} 核销应收账款',
                    created_by=self.created_by,
                )

                remaining_amount -= writeoff_amount
```

**验证标准**:
- ✅ 创建付款记录后自动核销应付账款
- ✅ 创建收款记录后自动核销应收账款
- ✅ 支持部分核销 (付款金额 < 应付金额)
- ✅ 支持多账款核销 (付款金额 > 单笔应付金额)
- ✅ 核销记录完整保存
- ✅ 账款余额和状态正确更新

**预估工作量**: 1.5天

---

### 阶段5: 信用额度校验 (2天)

#### 任务5.1: 实现信用额度实时计算

**目标**: 为Customer模型添加信用额度实时计算方法

**输入**:
- 客户当前欠款 (未付清的应收账款)
- 客户信用额度限制

**输出**:
- Customer模型方法: `get_current_credit_used()`
- Customer模型方法: `get_available_credit()`
- Customer模型方法: `is_credit_available(amount)`

**涉及文件**:
```
apps/customers/models.py            # 修改Customer模型
```

**实施细节**:

```python
# apps/customers/models.py 修改

class Customer(BaseModel):
    # ... 现有字段 ...

    def get_current_credit_used(self):
        """
        计算当前信用额度使用情况
        信用额度占用 = 未付清的应收账款余额
        """
        from apps.finance.models import CustomerAccount
        from django.db.models import Sum

        outstanding = CustomerAccount.objects.filter(
            customer=self,
            balance__gt=0  # 未付清的账款
        ).aggregate(total=Sum('balance'))['total'] or Decimal('0')

        return outstanding

    def get_available_credit(self):
        """
        计算可用信用额度
        可用额度 = 信用额度 - 当前欠款
        """
        used = self.get_current_credit_used()
        return self.credit_limit - used

    def is_credit_available(self, required_amount):
        """
        检查是否有足够的信用额度

        Args:
            required_amount: 需要的额度金额

        Returns:
            (bool, str): (是否可用, 提示信息)
        """
        available = self.get_available_credit()

        if available >= required_amount:
            return True, f'信用额度充足，可用: ¥{available}'
        else:
            shortage = required_amount - available
            return False, f'信用额度不足，缺口: ¥{shortage}，当前可用: ¥{available}，已用: ¥{self.get_current_credit_used()}，额度: ¥{self.credit_limit}'

    @property
    def credit_usage_percentage(self):
        """信用额度使用率"""
        if self.credit_limit == 0:
            return 0
        used = self.get_current_credit_used()
        return (used / self.credit_limit) * 100
```

**验证标准**:
- ✅ 可正确计算当前欠款金额
- ✅ 可正确计算可用信用额度
- ✅ 信用额度充足性判断准确
- ✅ 信用使用率计算正确

**预估工作量**: 0.5天

---

#### 任务5.2: 发货前信用额度校验与审批流程

**目标**: 在发货确认前校验客户信用额度，超限需审批

**输入**:
- 发货单信息
- 客户信用额度数据
- 用户权限信息

**输出**:
- 增强的 `delivery_ship` 视图 (增加校验逻辑)
- 信用额度超限审批视图
- 信用额度预警通知

**涉及文件**:
```
apps/sales/views.py                 # 修改delivery_ship视图，新增审批视图
apps/sales/urls.py                  # 新增审批路由
templates/sales/delivery_credit_warning.html  # 信用额度预警页面
```

**实施细节**:

```python
# apps/sales/views.py 修改

@login_required
@transaction.atomic
def delivery_ship(request, pk):
    """
    确认发货 (最终版)
    新增: 信用额度校验
    """
    delivery = get_object_or_404(Delivery, pk=pk)
    order = delivery.sales_order
    customer = order.customer

    # 检查状态
    if delivery.status != 'preparing':
        messages.error(request, '发货单已处理，无法重复确认')
        return redirect('sales:delivery_detail', pk=pk)

    # ✅ 信用额度校验 (在库存扣减之前)
    # 计算本次发货金额
    delivery_amount = sum([
        item.quantity * item.order_item.unit_price
        for item in delivery.items.all()
    ])

    # 检查信用额度
    credit_ok, credit_msg = customer.is_credit_available(delivery_amount)

    if not credit_ok:
        # 检查用户是否有绕过权限
        if not request.user.has_perm('sales.bypass_credit_check'):
            # 无权限，显示预警页面
            context = {
                'delivery': delivery,
                'customer': customer,
                'delivery_amount': delivery_amount,
                'credit_used': customer.get_current_credit_used(),
                'credit_limit': customer.credit_limit,
                'credit_available': customer.get_available_credit(),
                'credit_msg': credit_msg,
            }
            return render(request, 'sales/delivery_credit_warning.html', context)
        else:
            # 有权限，记录日志并继续
            from apps.core.models import AuditLog
            AuditLog.objects.create(
                user=request.user,
                action='bypass_credit_check',
                model_name='Delivery',
                object_id=str(delivery.id),
                details=f'绕过信用额度检查，{credit_msg}',
            )
            messages.warning(request, f'已绕过信用额度检查: {credit_msg}')

    # ... 继续原有发货逻辑 (库存出库、状态更新、创建应收账款等)
    # (见任务3.3的代码)

    # ... 发货成功后 ...

    messages.success(request, f'发货确认成功')
    return redirect('sales:delivery_detail', pk=pk)


# 新增: 信用额度超限审批
@login_required
@require_http_methods(['POST'])
@transaction.atomic
def delivery_credit_approve(request, pk):
    """
    审批超限发货
    需要特定权限
    """
    # 检查权限
    if not request.user.has_perm('sales.approve_credit_override'):
        messages.error(request, '您没有审批超限发货的权限')
        return redirect('sales:delivery_detail', pk=pk)

    delivery = get_object_or_404(Delivery, pk=pk)

    # 记录审批
    from apps.core.models import AuditLog
    AuditLog.objects.create(
        user=request.user,
        action='approve_credit_override',
        model_name='Delivery',
        object_id=str(delivery.id),
        details=f'审批通过超限发货',
    )

    # 标记发货单已审批
    delivery.credit_approved = True  # 需要在Delivery模型添加此字段
    delivery.credit_approved_by = request.user
    delivery.credit_approved_at = timezone.now()
    delivery.save()

    messages.success(request, '超限发货已审批通过，可以继续发货')

    # 重定向到发货确认
    return redirect('sales:delivery_ship', pk=pk)


# 新增: 信用额度预警通知
def _send_credit_warning_notification(customer, delivery):
    """
    发送信用额度预警通知
    """
    from apps.core.models import Notification

    # 通知销售代表
    if customer.sales_rep:
        Notification.objects.create(
            recipient=customer.sales_rep,
            title=f'客户信用额度预警 - {customer.name}',
            message=f'客户 {customer.name} 信用额度不足，发货单 {delivery.delivery_number} 待审批',
            notification_type='warning',
            link_url=f'/sales/deliveries/{delivery.id}/',
        )

    # 通知财务负责人 (可配置)
    # ...
```

**需要在Delivery模型添加字段**:

```python
# apps/sales/models.py 修改Delivery模型

class Delivery(BaseModel):
    # ... 现有字段 ...

    # 信用额度审批字段
    credit_approved = models.BooleanField('信用额度已审批', default=False)
    credit_approved_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='credit_approved_deliveries',
        verbose_name='信用审批人'
    )
    credit_approved_at = models.DateTimeField('信用审批时间', null=True, blank=True)
```

**需要添加权限**:

```python
# apps/sales/models.py Delivery的Meta中添加

class Delivery(BaseModel):
    # ...

    class Meta:
        # ... 现有配置 ...
        permissions = [
            ('bypass_credit_check', '可以绕过信用额度检查'),
            ('approve_credit_override', '可以审批超限发货'),
        ]
```

**验证标准**:
- ✅ 发货前自动校验客户信用额度
- ✅ 信用额度充足时正常发货
- ✅ 信用额度不足时阻止发货，显示预警页面
- ✅ 有权限的用户可以绕过校验
- ✅ 有权限的用户可以审批超限发货
- ✅ 审批记录完整保存
- ✅ 相关人员收到预警通知

**预估工作量**: 1.5天

---

## 需要进一步明确的问题

### 问题1: 对账单是否需要供应商/客户确认?

当前设计中，对账单有"已提交"、"已确认"等状态，但未明确确认机制。

**推荐方案**:

- **方案A: 仅内部使用** (简单)
  - 对账单仅供内部财务核对使用
  - 不需要供应商/客户确认
  - 状态流转: 草稿 → 已审核 → 已完成
  - 优点: 实施简单，无需额外通信机制
  - 缺点: 可能与供应商/客户存在差异

- **方案B: 需要确认** (完整)
  - 对账单需要供应商/客户确认
  - 提供在线确认或线下签字确认功能
  - 状态流转: 草稿 → 已提交 → 供应商/客户确认 → 已审核 → 已完成
  - 优点: 双方认可，避免纠纷
  - 缺点: 需要额外开发确认机制，增加沟通成本

**等待用户选择**:

```
请选择您偏好的方案，或提供其他建议：
[ ] 方案A: 仅内部使用
[ ] 方案B: 需要供应商/客户确认
[ ] 其他方案：___________________
```

---

### 问题2: 发票管理的详细程度?

当前设计的Invoice模型包含基础字段，但未明确是否需要管理详细的税务信息。

**推荐方案**:

- **方案A: 基础发票管理** (快速)
  - 记录发票号、金额、税额等基本信息
  - 支持上传发票PDF/图片
  - 不深入管理税务细节
  - 优点: 快速上线，满足基本需求
  - 缺点: 税务信息不够详细

- **方案B: 完整税务管理** (专业)
  - 记录发票所有税务信息 (购买方/销售方税号、地址电话、开户行等)
  - 支持增值税专用发票、普通发票等多种类型
  - 集成税务认证状态
  - 支持发票验真
  - 优点: 税务合规，信息完整
  - 缺点: 开发工作量大

**等待用户选择**:

```
请选择您偏好的方案，或提供其他建议：
[ ] 方案A: 基础发票管理
[ ] 方案B: 完整税务管理
[ ] 其他方案：___________________
```

---

### 问题3: 核销策略 - 先进先出 (FIFO) 还是手动指定?

当前设计中，核销逻辑按到期日先后顺序核销，但可能需要更灵活的策略。

**推荐方案**:

- **方案A: 自动FIFO核销** (简单)
  - 收付款自动核销最早到期的账款
  - 无需人工干预
  - 优点: 简单自动，减少操作
  - 缺点: 灵活性不足

- **方案B: 手动指定核销** (灵活)
  - 收付款时可手动选择核销哪些账款
  - 支持部分核销和跨订单核销
  - 优点: 灵活性高，适应复杂场景
  - 缺点: 操作复杂，增加工作量

- **方案C: 混合模式** (推荐)
  - 默认自动FIFO核销
  - 提供手动调整功能
  - 优点: 兼顾简单和灵活
  - 缺点: 实现稍复杂

**等待用户选择**:

```
请选择您偏好的方案，或提供其他建议：
[ ] 方案A: 自动FIFO核销
[ ] 方案B: 手动指定核销
[ ] 方案C: 混合模式 (推荐)
[ ] 其他方案：___________________
```

---

### 问题4: 信用额度预警阈值?

当前设计中，信用额度超限时阻止发货，但可能需要提前预警。

**推荐方案**:

- **方案A: 仅超限拦截** (简单)
  - 只在超限时拦截
  - 无提前预警
  - 优点: 简单直接
  - 缺点: 无预警，可能影响业务

- **方案B: 多级预警** (专业)
  - 信用使用率达80%时黄色预警
  - 信用使用率达90%时橙色预警
  - 信用使用率达100%时红色拦截
  - 优点: 提前预警，给业务缓冲时间
  - 缺点: 需要额外的预警机制

**等待用户选择**:

```
请选择您偏好的方案，或提供其他建议：
[ ] 方案A: 仅超限拦截
[ ] 方案B: 多级预警 (建议阈值: 80%, 90%, 100%)
[ ] 其他方案 (自定义阈值): ___________________
```

---

## 用户反馈区域

请在此区域补充您对整体规划的意见和建议：

```
用户补充内容：

---
1. 对账单确认机制的选择:


---
2. 发票管理详细程度的选择:


---
3. 核销策略的选择:


---
4. 信用额度预警阈值的选择:


---
5. 其他意见或需求:


---
```

---

## 实施风险提示

### 技术风险
1. **数据一致性风险**: 自动创建账款和核销涉及多表操作，必须使用 `@transaction.atomic` 确保原子性
2. **性能风险**: 信用额度计算需要汇总大量账款数据，可能影响性能，建议：
   - 为CustomerAccount和SupplierAccount的balance字段添加索引
   - 考虑在Customer模型添加缓存字段 `credit_used_cache`
3. **金额精度风险**: 使用Decimal类型，避免float运算导致精度丢失

### 业务风险
1. **账期计算不准确**: 需要与财务确认账期解析规则 (net_30, net_60等)
2. **核销顺序争议**: 需要明确核销策略，避免与财务实务冲突
3. **信用额度争议**: 需要明确信用额度的计算规则和超限审批流程

### 建议
1. **阶段性上线**: 每完成一个阶段立即测试验证
2. **财务复核**: 关键逻辑需要财务人员复核
3. **数据备份**: 上线前做好数据备份
4. **灰度发布**: 先在部分订单上试运行

---

## 验收标准总结

### 功能验收
- ✅ 发票可正常创建、编辑、关联业务单据
- ✅ 采购对账单自动生成，金额计算正确
- ✅ 销售对账单自动生成，金额计算正确
- ✅ 收货确认后自动创建应付账款
- ✅ 发货确认后自动创建应收账款
- ✅ 付款自动核销应付账款
- ✅ 收款自动核销应收账款
- ✅ 发货前信用额度校验生效
- ✅ 信用额度超限需要审批

### 数据验收
- ✅ 所有金额计算精确无误差
- ✅ 账款余额实时更新正确
- ✅ 核销记录完整保存
- ✅ 审计日志记录完整

### 性能验收
- ✅ 信用额度计算响应时间 < 1秒
- ✅ 对账单生成响应时间 < 3秒
- ✅ 核销操作响应时间 < 1秒

---

**文档版本**: v1.0
**制定人**: AI Assistant
**制定日期**: 2025-11-09
**预计完成时间**: 13个工作日 (约3周)
**下一步**: 等待用户确认不明确问题的选择，然后开始实施
